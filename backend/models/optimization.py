from sqlalchemy import Column, Integer, String, Float, DateTime, Index, Boolean
from sqlalchemy.orm import validates
from utils.database import Base
from utils.logger import logger
from datetime import datetime
from typing import Dict, Any, Optional

class Optimization(Base):
    """Model representing optimization proposals generated by the multi-agent system."""
    
    __tablename__ = "optimizations"

    # Primary fields
    id = Column(Integer, primary_key=True, index=True, autoincrement=True, doc="Unique identifier for the optimization")
    identifier = Column(String, index=True, nullable=False, doc="Unique identifier linking to the data source or context")
    proposal = Column(String, nullable=False, doc="Description of the proposed optimization")

    # Metadata fields
    agent_id = Column(String, nullable=True, doc="ID of the agent that generated this proposal")
    confidence = Column(Float, nullable=True, default=0.5, doc="Confidence score of the proposal (0.0 to 1.0)")
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False, doc="Timestamp when the proposal was created")
    implemented_at = Column(DateTime, nullable=True, doc="Timestamp when the proposal was implemented")
    status = Column(String, default="proposed", nullable=False, doc="Status of the proposal (e.g., 'proposed', 'implemented', 'rejected')")
    is_actionable = Column(Boolean, default=True, nullable=False, doc="Whether the proposal is immediately actionable")

    # Define composite index for efficient querying
    __table_args__ = (
        Index("ix_optimizations_identifier_created_at", "identifier", "created_at"),
    )

    @validates("identifier")
    def validate_identifier(self, key: str, value: str) -> str:
        """
        Validate the identifier field.

        Args:
            key (str): Field name ('identifier').
            value (str): Value to validate.

        Returns:
            str: Validated identifier.

        Raises:
            ValueError: If identifier is empty or too long.
        """
        if not value or len(value.strip()) == 0:
            logger.error("Identifier cannot be empty")
            raise ValueError("Identifier cannot be empty")
        if len(value) > 255:
            logger.warning(f"Identifier truncated from {len(value)} to 255 characters")
            return value[:255]
        return value

    @validates("proposal")
    def validate_proposal(self, key: str, value: str) -> str:
        """
        Validate the proposal field.

        Args:
            key (str): Field name ('proposal').
            value (str): Value to validate.

        Returns:
            str: Validated proposal.

        Raises:
            ValueError: If proposal is empty.
        """
        if not value or len(value.strip()) == 0:
            logger.error("Proposal cannot be empty")
            raise ValueError("Proposal cannot be empty")
        return value

    @validates("confidence")
    def validate_confidence(self, key: str, value: Optional[float]) -> Optional[float]:
        """
        Validate the confidence field.

        Args:
            key (str): Field name ('confidence').
            value (float, optional): Value to validate.

        Returns:
            float: Validated confidence score.

        Raises:
            ValueError: If confidence is not between 0.0 and 1.0.
        """
        if value is None:
            return 0.5  # Default confidence
        if not 0.0 <= value <= 1.0:
            logger.warning(f"Confidence {value} out of range [0, 1]; clamping to 0.5")
            return 0.5
        return value

    @validates("status")
    def validate_status(self, key: str, value: str) -> str:
        """
        Validate the status field.

        Args:
            key (str): Field name ('status').
            value (str): Value to validate.

        Returns:
            str: Validated status.

        Raises:
            ValueError: If status is invalid.
        """
        valid_statuses = {"proposed", "implemented", "rejected", "under_review"}
        if value.lower() not in valid_statuses:
            logger.warning(f"Invalid status: {value}; defaulting to 'proposed'")
            return "proposed"
        return value.lower()

    def to_dict(self) -> Dict[str, Any]:
        """
        Serialize the model instance to a dictionary.

        Returns:
            Dict[str, Any]: Dictionary representation of the instance.
        """
        return {
            "id": self.id,
            "identifier": self.identifier,
            "proposal": self.proposal,
            "agent_id": self.agent_id,
            "confidence": self.confidence,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "implemented_at": self.implemented_at.isoformat() if self.implemented_at else None,
            "status": self.status,
            "is_actionable": self.is_actionable
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any], agent_id: Optional[str] = None) -> "Optimization":
        """
        Create an Optimization instance from a dictionary.

        Args:
            data (Dict[str, Any]): Data dictionary with fields.
            agent_id (str, optional): ID of the agent proposing the optimization.

        Returns:
            Optimization: New instance of the model.
        """
        try:
            instance = cls(
                identifier=data["identifier"],
                proposal=data["proposal"],
                agent_id=agent_id or data.get("agent_id"),
                confidence=data.get("confidence", 0.5),
                created_at=datetime.fromisoformat(data["created_at"]) if data.get("created_at") else datetime.utcnow(),
                implemented_at=datetime.fromisoformat(data["implemented_at"]) if data.get("implemented_at") else None,
                status=data.get("status", "proposed"),
                is_actionable=data.get("is_actionable", True)
            )
            return instance
        except Exception as e:
            logger.error(f"Failed to create Optimization from dict: {e}")
            raise ValueError(f"Invalid data for Optimization: {e}")

if __name__ == "__main__":
    # Test the model
    from sqlalchemy import create_engine
    from sqlalchemy.orm import Session as OrmSession
    from utils.database import Base

    # Setup test database
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    
    with OrmSession(engine) as session:
        # Test creation
        test_data = {
            "identifier": "test_data",
            "proposal": "Adjust antenna tilt by 2 degrees",
            "agent_id": "optimization_agent_1",
            "confidence": 0.9,
            "is_actionable": True
        }
        optimization = Optimization.from_dict(test_data)
        session.add(optimization)
        session.commit()

        # Test retrieval
        retrieved = session.query(Optimization).first()
        print("Retrieved:", retrieved.to_dict())

        # Test validation
        try:
            invalid_optimization = Optimization(identifier="", proposal="")
            session.add(invalid_optimization)
            session.commit()
        except ValueError as e:
            print(f"Validation Error: {e}")